Tutorial: How to build a GraphQL server Talk to MongoDB, SQL and REST with these simple steps Earlier this week, we released a technical preview for Apollo , a GraphQL data stack. Apollo has two parts so far: An easy-to-use GraphQL client that integrates with React, Angular, Redux, and Meteor. An opinionated guide and tools for building a JavaScript GraphQL server. Today's post is going to be a tutorial for the second part - how to build a GraphQL server that connects to multiple backends: A SQL database, a MongoDB database and a REST endpoint. We'll be combining all of them to build a very basic blog with authors, posts and views. The tutorial has seven parts: Setting up Defining a schema Quickly setting up a mocked server Writing resolvers Connecting to a SQL database Connecting to MongoDB Using REST services from GraphQL If you prefer watching a video instead of reading this tutorial, you're in luck. You can either read this post or watch the video, they both cover the same steps. 1. Setting up This tutorial assumes that you've already set up Node.js and npm for your computer, and that you know how to copy-paste things to the command line. Naturally, you'll also need a text editor of sorts. To follow along with the MongoDB part (optional), you'll also need a MongoDB server running somewhere. If you have all of that, there is just a little bit more boilerplate to set up: Babel for ES6 features, and a simple express server. You can do this yourself if you like, but you can also just clone the starter-kit for this tutorial: git clone cd apollo-starter-kit git checkout server-only npm install This will download the starter-kit from GitHub and install all the npm packages you need to get started. Once the installation is finished, you can launch the server with this command: npm start If all goes well, the server should now print out a message that it is listening on port 8080. If you open localhost:8080 in your browser, you should now see the GraphiQL GUI: If it worked, you're all ready to get started writing your GraphQL server! 2. Defining a schema At the core of any GraphQL server is a schema. The schema defines types and their relationships. It also specifies which queries can be made against the server. In our example, the schema is defined in data/schema.js: ApolloServer uses the GraphQL schema language notation, which it then compiles to a GraphQL-JS schema. With the current schema, our server provides exactly one root query: testString, which returns a String. The schema notation supports all GraphQL types. In this tutorial we are only going to use a few of them. If you want to know about the others, you can check out the Apollo docs . For our blog app, we now have to modify schema.js and add the types we need. You can write those inside the typeDefinitions string. Author is going to have four fields: id, firstName, lastName and posts. Posts is an array that refers to that author's posts. type Author { id: Int firstName: String lastName: String posts: [Post] } Post is going to have five fields: id, title, text, views and author. Author refers to the author type we just defined: type Post { id: Int title: String text: String views: Int author: Author } Now that we've defined the types, we need to modify the Query type to tell the server about the queries that users are allowed to type Query { author(firstName: String, lastName: String): Author getFortuneCookie: String # we'll use this later } schema { query: Query } Your schema.js file should now look as follows: 3. Mocking If you used the `npm start` command to start the server, it will have updated automatically, so you can go to , and run the following query: { author(firstName:"Edmond", lastName: "Jones"){ firstName lastName posts{ title views } } } You should get a response that looks something like this: { "data": { "author": { "firstName": "It works!" "lastName": "It works!" "posts": [{ "title": "It works!" "views": 34 }, { "title": "It works!" "views": -22 }] } } } Are you wondering how your GraphQL came up with that response, even though we didn't tell it where to get the data from? It's quite simple actually, we told the server in the starter-kit to mock the data, and that's what it's doing. The data doesn't look very realistic though, so we're going to have to change that. If you're not interested in mocking, you can skip to the next section. If you're not sure whether you should be interested in mocking, you can take a quick look at my post on mocking , which explains the benefits. Alright then, let's change the mocking to make it a bit more realistic. Right now the server is using the same string everywhere. We're going to tell it how to mock a first and last name for Author, and how to mock title, text and views for Post. We'll also tell it that if we queried for a specific author, the author returned should have the name we searched for. In order to do that, we're going to use an npm package called "casual", which you should now install by running "npm install casual". Once casual is installed, go ahead and modify the file data/mock.js to look like this: I won't explain here how it works exactly. At a high level, mocks for each type just define a function that gets run when an object of that type should be returned. You can find more information here . Go ahead and rerun the query you ran earlier. The output should make a lot more sense now. 4. Writing resolvers So far, we've only set up the schema and tested it with some mock data. In order for the server to be more useful, we have to tell it how to respond to a query. In GraphQL, this is done through resolve functions. Every field can have a resolve function, which tells the GraphQL server how to return data for that field, if it appears in a query. The first resolve function for the author field on Query is the first one to be called for the example query that you ran earlier. The return value of that resolve function then gets passed to the resolve functions on the fields of Author, for example posts. The result of that gets passed on to the next resolve function, until a so-called scalar type is reached. Scalar types are GraphQL-speak for leaf nodes in the graph. Let's go ahead and define resolve functions for our schema. At the minimum, we need to define a resolve function for each field that either returns a non-scalar type or takes any arguments. We'll defined the resolve functions in data/resolvers.js. Create that file and copy-paste the following: Before you can try the new server, we need to tell it to stop using mock data and call the resolve functions instead. Change server.js to uncomment mocks and add the resolvers (make sure you don't forget to import data/resolvers.js) import Resolvers from './data/mocks'; // more code ... graphQLServer.use('/', apolloServer({ graphiql: true, pretty: true, schema: Schema, resolvers: Resolvers, // mocks: Mocks, })); If you run the query from earlier again, you'll see that it returns exactly what the resolve functions return. Now that we understand how resolve functions work, let's hook them up to a SQL database! 5. Connecting to SQL In order to get our data from a SQL database into the GraphQL response, we're going to write a connector, and then use those connectors from the resolve function. Technically you could write the database connection logic directly in the resolve functions, but it's much better to keep your resolve functions extremely simple and separate your concerns that way. If you need to change backends later, only your connectors have to change, the resolve functions can stay the same. In this example, we'll use sequelize - a SQL ORM - to connect to a sqlite database. First, install both sequelize and sqlite: npm install sequelize sqlite Next, create a file in the data folder called "connectors.js". In it, we'll set up the database connection and define the schema of our database. To have some data to query, we'll use casual again to create some fake data every time the server starts: Now that we have the connectors, we have to modify our resolvers file to import and use the connector we just defined. It's pretty straightforward: Go ahead and run the original query again in your GraphiQL window. You should get the following output: { "data": { "author": { "firstName": "Edmond", "lastName": "Jones", "posts": [ { "title": "A post by Edmond", "views": null } ] } } } That wasn't hard at all, right? Let's add MongoDB to the mix. 6. Connecting to MongoDB Now I want to show you one of the greatest features of GraphQL: joining across different backends, in this case SQL and MongoDB. Of course, we could have used the SQL database for the views as well, but often you have to work with existing legacy backends, or you have certain scaling requirements that can only be met by splitting your backend into different services. To illustrate how useful Apollo can be in those cases, we're going to use MongoDB to store the views. For this next part to work, you need to have MongoDB installed and configured correctly on your computer. If that's not the case, feel free to just skim the code or skip to the next section. Still here? Great! Let's get MongoDB wired up to our GraphQL schema. As you probably guessed, we first need to define a connector. Let's do that by adding it to connectors.js. By now you'll probably be able to figure out where each part should go. Make sure you don't forget to npm install mongoose! In resolvers.js, change the Post resolve functions to the following: Post: { author(post) { return post.getAuthor(); }, views(post) { return View.findOne({ postId: post.id }) .then((view) => view.views); }, }, If you run the original query again now, views should be pulled from MongoDB and no longer be null. 7. Querying a REST endpoint Finally, let's also add a REST endpoint to the mix. GraphQL resolve functions can either directly return a value, or they can return a promise. You may not have realized it, but we've been taking advantage of that all along: both sequelize and mongoose return promises! One thing that these promises let us do is get data from other services. I couldn't really think of a great example API to include here, so I ended up choosing the fortune cookie API. It doesn't have anything to do with the rest of the example, but it's good enough to illustrate the concept. First, you'll have to install an npm package called request-promise. Once that's done, add the following to connectors.js: Now that you have the connector, I'm sure you can figure out how to modify resolvers.js to use the connector! To see if you did it right, you can run the following query: { author(firstName: "Edmond", lastName: "Jones"){ firstName lastName } getFortuneCookie } You should get a response that looks similar to this: { "data": { "author": { "firstName": "Edmond", "lastName": "Jones" }, "getFortuneCookie": "You can't unscramble a scrambled egg." } } Did it work? If so, congratulations, you've just completed this tutorial and written a GraphQL server that uses a SQL, MongoDB and REST!!! If it didn't quite work, you can always take a look at the server-tutorial-solution branch and compare it to your files. Conclusion I hope you've enjoyed this tutorial! If you ran into any issues, please let me know in the comments or file an issue on the apollo-starter-kit repository! This tutorial just covered the basics. If you want to build a production-ready GraphQL server with Apollo, you'll also have to consider things like authentication, authorization, caching, logging, input validation etc. We'll cover these in future tutorials. I'm also hoping to make a tutorial for apollo-client in the near future, so if any of these are of interest to you, make sure to follow Building Apollo and check back every now and then to see what's new!