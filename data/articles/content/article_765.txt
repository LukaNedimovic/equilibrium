Illustration by Justin Mezzell by Published in Mehdi Maujood JavaScript Douglas Crockford accurately described JavaScript as the world's most misunderstood language. A lot of programmers tend to think of it as not a "proper" language because it lacks the common object-oriented programming concepts. I myself developed the same opinion after my first JavaScript project ended up a hodgepodge, as I couldn't find a way to organize code into classes. But as we will see, JavaScript comes packed with a rich system of object-oriented programming that many programmers don't know about. Back in the time of the First Browser War , executives at Netscape hired a smart guy called Brendan Eich to put together a language that would run in the browser. Unlike class-based languages like C++ and Java, this language, which was at some point called LiveScript, was designed to implement a prototype-based inheritance model. Prototypal OOP, which is conceptually different from the class-based systems, had been invented just a few years before to solve some problems that class-based OOP presented and it fit very well with LiveScript's dynamic nature. Unfortunately, this new language had to "look like Java" for marketing reasons. Java was the cool new thing in the tech world and Netscape's executives wanted to market their shiny new language as "Java's little brother." This seems to be why its name was changed to JavaScript. The prototype-based OOP system, however, didn't look anything like Java's classes. To make this prototype-based system look like a class-based system, JavaScript's designers came up with the keyword new and a novel way to use constructor functions. The existence of this pattern and the ability to write "pseudo class-based" code has led to a lot of confusion among developers. Understanding the rationale behind prototype-based programming was my "aha" moment with JavaScript and resolved most of the gripes I had with the language. I hope learning about prototype-based OOP brings you the same peace of mind it brought me. And I hope that exploring a technique that has not been fully explored excites you as much as it excites me. Prototype-based OOP Conceptually, in class-based OOP, we first create a class to serve as a "blueprint" for objects, and then create objects based on this blueprint. To build more specific types of objects, we create "child" classes; i.e., we make some changes to the blueprint and use the resulting new blueprint to construct the more specific objects. For a real-world analogy, if you were to build a chair, you would first create a blueprint on paper and then manufacture chairs based on this blueprint. The blueprint here is the class, and chairs are the objects. If you wanted to build a rocking chair, you would take the blueprint, make some modifications, and manufacture rocking chairs using the new blueprint. Now take this example into the world of prototypes: you don't create blueprints or classes here, you just create the object. You take some wood and hack together a chair. This chair, an actual object, can function fully as a chair and also serve as a prototype for future chairs. In the world of prototypes, you build a chair and simply create "clones" of it. If you want to build a rocking chair, all you have to do is pick a chair you've manufactured earlier, attach two rockers to it, and voil√†! You have a rocking chair. You didn't really need a blueprint for that. Now you can just use this rocking chair for yourself, or perhaps use it as a prototype to create more rocking chairs. JavaScript and prototype-based OOP Following is an example that demonstrates this kind of OOP in JavaScript. We start by creating an animal object: Object.create(null) creates a new empty object. (We will discuss Object.create() in further detail later.) Next, we add some properties and functions to our new object: genericAnimal is a proper object and can be used like one: We can create other, more specific animals by using our sample object as a prototype. Think of this as cloning the object, just like we took a chair and created a clone in the real world. We just created a cat as a clone of the generic animal. We can add properties and functions to this: We can use our cat as a prototype and create a few more cats: You can also observe that properties/methods from parents were properly carried over: The new keyword and the constructor function JavaScript has the concept of a new keyword used in conjunction with constructor functions. This feature was built into JavaScript to make it look familiar to people trained in class-based programming. You may have seen JavaScript OOP code that looks like this: Implementing inheritance using JavaScript's default method looks more complicated. We define Ninja as a sub-class of Person . Ninjas can have a name as they are a person, and they can also have a primary weapon, such as shuriken. While the constructor pattern might look more attractive to an eye that's familiar with class-based OOP, it is considered problematic by many. What's happening behind the scenes is prototypal OOP, and the constructor function obfuscates the language's natural implementation of OOP. This just looks like an odd way of doing class-based OOP without real classes, and leaves the programmer wondering why they didn't implement proper class-based OOP. Since it's not really a class, it's important to understand what a call to a constructor does. It first creates an empty object, then sets the prototype of this object to the prototype property of the constructor, then calls the constructor function with this pointing to the newly-created object, and finally returns the object. It's an indirect way of doing prototype-based OOP that looks like class-based OOP. The problem with JavaScript's constructor pattern is succinctly summed up by Douglas Crockford: JavaScript's constructor pattern did not appeal to the classical crowd. It also obscured JavaScript's true prototypal nature. As a result, there are very few programmers who know how to use the language effectively. The most effective way to work with OOP in JavaScript is to understand prototypal OOP, whether the constructor pattern is used or not. Understanding delegation and the implementation of prototypes So far, we've seen how prototypal OOP differs from traditional OOP in that there are no classes-only objects that can inherit from other objects. Every object in JavaScript holds a reference to its parent (prototype) object. When an object is created through Object.create , the passed object-meant to be the prototype for the new object-is set as the new object's prototype. For the purpose of understanding, let's assume that this reference is called __proto__ 1 . Some examples from the previous code can illustrate this point: The line below creates a new empty object with __proto__ as null. The code below then creates a new empty object with __proto__ set to the genericAnimal object, i.e. rodent.__proto__ points to genericAnimal . The following line will create an empty object with __proto__ pointing to rodent. As we can see, every object holds a reference to its prototype. Looking at Object.create without knowing what exactly it does, it might look like the function actually "clones" from the parent object, and that properties of the parent are copied over to the child, but this is not true. When capybara is created from rodent , capybara is an empty object with only a reference to rodent . But then-if we were to call capybara.size right after creation, we would get S , which was the size we had set in the parent object. What blood-magic is that? capybara doesn't have a size property yet. But still, when we write capybara.size , we somehow manage to see the prototype's size property. The answer is in JavaScript's method of implementing inheritance: delegation. When we call capybara.size , JavaScript first looks for that property in the capybara object. If not found, it looks for the property in capybara.__proto__ . If it didn't find it in capybara.__proto__ , it would look in capybara.__proto__.__proto__ . This is known as the prototype chain. If we called capybara.description() , the JavaScript engine would start searching up the prototype chain for the description function and finally discover it in capybara.__proto__.__proto__ as it was defined in genericAnimal . The function would then be called with this pointing to capybara . Setting a property is a little different. When we set capybara.size = 'XXL' , a new property called size is created in the capybara object. Next time we try to access capybara.size , we find it directly in the object, set to 'XXL' . Since the prototype property is a reference, changing the prototype object's properties at runtime will affect all objects using the prototype. For example, if we rewrote the description function or added a new function in genericAnimal after creating rodent and capybara , they would be immediately available for use in rodent and capybara , thanks to delegation. Creating Object.create When JavaScript was developed, its default way of creating objects was the keyword new . Then many notable JavaScript developers campaigned for Object.create , and eventually it was included in the standard. However, some browsers don't support Object.create (you know the one I mean). For that reason, Douglas Crockford recommends including the following code in your JavaScript applications to ensure that Object.create is created if it is not there: Object.create in action If you wanted to extend JavaScript's Math object, how would you do it? Suppose that we would like to redefine the random function without modifying the original Math object, as other scripts might be using it. JavaScript's flexibility provides many options. But I find using Object.create a breeze: Couldn't possibly get any simpler than that. You could, if you prefer, write a new constructor, set its prototype to a clone of Math , augment the prototype with the functions you like, and then construct the actual object. But why go through all that pain to make it look like a class, when prototypes are so simple? We can now redefine the random function in our myMath object. In this case, I wrote a function that returns random whole numbers within a range if the user specifies one. Otherwise, it just calls the parent's random function. There! Now myMath.random(-5,5) gets you a random whole number between ‚àí5 and 5, while myMath.random() gets the usual. And since myMath has Math as its prototype, it has all the functionality of the Math object built into it. Class-based OOP vs. prototype-based OOP Prototype-based OOP and class-based OOP are both great ways of doing OOP; both approaches have pros and cons. Both have been researched and debated in the academic world since before I was born. Is one better than the other? There is no consensus on that. But the key points everyone can agree on are that prototypal OOP is simpler to understand, more flexible, and more dynamic. To get a glimpse of its dynamic nature, take the following example: you write code that extensively uses the indexOf function in arrays. After writing it all down and testing in a good browser, you grudgingly test it out in Internet Explorer 8. As expected, you face problems. This time it's because indexOf is not defined in IE8. So what do you do? In the class-based world, you could solve this by defining the function, perhaps in another "helper" class which takes an array or List or ArrayList or whatever as input, and replacing all the calls in your code. Or perhaps you could sub-class the List or ArrayList and define the function in the sub-class, and use your new sub-class instead of the ArrayList. But JavaScript and prototype-based OOP's dynamic nature makes it simple. Every array is an object and points to a parent prototype object. If we can define the function in the prototype, then our code will work as is without any modification! You can do many cool things once you ditch classes and objects for JavaScript's prototypes and dynamic objects. You can extend existing prototypes to add new functionality-extending prototypes like we did above is how the well known and aptly named library Prototype.js adds its magic to JavaScript's built-in objects. You can create all sorts of interesting inheritance schemes, such as one that inherits selectively from multiple objects. Its dynamic nature means you don't even run into the problems with inheritance that the Gang of Four book famously warns about. (In fact, solving these problems with inheritance was what prompted researchers to invent prototype-based OOP-but all that is beyond our scope for this article.) Class-based OOP emulation can go wrong Consider the following very simple example written with pseudo-classes: The example looks innocent enough. This is an inheritance pattern that you will see in many places all over the internet. However, something funny is going on here-if you check colonel.offspring and puff.offspring , you will notice that each of them contains the same two babies! That's probably not what you intended-unless you are coding a quantum physics thought experiment. JavaScript tried to make our lives easier by making it look like we have good old class-based OOP going on. But it turns out it's not that simple. Simulating class-based OOP without completely understanding prototype-based OOP can lead to unexpected results. To understand why this problem occurred, you must understand prototypes and how constructors are just one way to build objects from other objects. What happened in the above code is very clear if you think in terms of prototypes. The variable offspring is created when the Animal constructor is called-and it is created in the Cat.prototype object. All individual objects created with the Cat constructor use Cat.prototype as their prototype, and Cat.prototype is where offspring resides. When we call makeBaby , the JavaScript engine searches for the offspring property in the Cat object and fails to find it. It then finds the property in Cat.prototype -and adds the new baby in the shared object that both individual Cat objects inherit from. So now that we understand what the problem is, thanks to our knowledge of the prototype-based system, how do we solve it? The solution is that the offspring property needs to be created in the object itself rather than somewhere in the prototype chain. There are many ways to solve it. One way is that makeBaby ensures that the object on which the function is called has its own offspring property: Backbone.js runs into a similar trap. In Backbone.js, you build views by extending the base Backbone.View "class." You then instantiate views using the constructor pattern. This model is very good at emulating class-based OOP in JavaScript: This looks like simple class-based OOP. We inherited from the base Backbone.View class to create a HideableView child class. Next, we created an object of type HideableView . Since this looks like simple class-based OOP, we can use this functionality to conveniently build inheritance hierarchies, as shown in the following example: This all looks good while you're thinking in class-based OOP. But if you try table.events['click .expand'] in the console, you will see "expand"! Somehow, HideableTableView has an expand click handler, even though it was never defined in this class. You can see the problem in action here: The problem above occurred because of the same reason outlined in the earlier example. In Backbone.js, you need to work against the indirection created by trying to make it look like classes, to see the prototype chain hidden in the background. Once you comprehend how the prototype chain would be structured, you will be able to find a simple fix for the problem. In conclusion Despite prototypal OOP underpinning one of the most popular languages out there today, programmers are largely unfamiliar with what exactly prototype-based OOP is. JavaScript itself may be partly to blame because of its attempts to masquerade as a class-based language. This needs to change. To work effectively with JavaScript, developers need to understand the how and why of prototype-based programming-and there's much more to it than this article. Beyond mastering JavaScript, in learning about prototype-based programming you can also learn a lot of things about class-based programming as you get to compare and contrast the two different methods. Further Reading Douglas Crockford's note on protoypal programming was written before Object.create was added to the standard. An article on IBM's developerWorks reinforces the same point on prototypal OOP. This article was the prototypal "aha" moment for me. The following three texts will be interesting reads if you're willing to dive into the academic roots of prototype-based programming: Henry Lieberman of MIT Media Labs compares class-based inheritance with prototype-based delegation and argues that prototype-based delegation is the more flexible of the two concepts. Classes versus Prototypes in Object-Oriented Languages is a proposal to use prototypes instead of classes by the University of Washington's Alan Borning. Lieberman's and Borning's work in the 1980s appears to have influenced the work that David Ungar and Randall Smith did to create the first prototype-based programming language: Self. Self went on to become the basis for the prototype-based system in JavaScript. This paper describes their language and how it omits classes in favor of prototypes. In this excerpt, Aaron Gustafson looks at the limitations of JavaScript and advocates for a solution: progressive enhancement. A headless CMS could solve one or more problems for you, and implementing it is more doable than you may realize. Get our latest articles in your inbox. Sign up for email alerts .