Introduction JSR 372 is currently in the Early Draft Review stage. The JSF 2.3 spec is not complete and will likely change significantly before finalization. In the meantime, here's a pragmatic deep-dive into JSF 2.3 in its current state. For more resources, see JavaServer Faces 2.3 Tutorial and JSF 2.3 Repository Examples . CDI Alignment Injection and EL Resolving of JSF artifacts As you probably know, JSF uses static entry methods and chaining to let the user obtain the various artifacts that it provides, such as the FacesContext, session map, external context, etc. However, this is pretty verbose and sometimes hard to intuit and understand. JSF 2.3 will therefore provide default producers for the most important artifacts, which at the moment are: FacesContext #{facesContext} ExternalContext #{externalContext} UIViewRoot #{view} ServletContext #{application} Flash #{flash} Application Map #{applicationScope} Session Map #{sessionScope} View Map #{viewScope} Request Map #{requestScope} Flow Map #{flowScope} Header Map #{header} Cookie Map #{cookie} Init Param Map #{initParam} Request Param Map #{param} Request Values Map #{paramValues} Header Values Map #{headerValues} Resource Handler #{"resource"} The following artifacts are not injectable: Composite Component (#{cc}), Component (#{component}), Request (#{request}), Session (#{session}) Must Read Injection and EL resolving of JSF artifacts (by Arjan Tijms) Related JSF 2.3 Injection and EL resolving of JSF artifacts Injection in More JSF Artifacts JSF 2.0 provides very modest support for injection in JSF artifacts. In JSF 2.1, very few JSF artifacts were injection targets. Starting with JSF 2.2, injection is possible in many more artifacts (check Mastering JavaServer Faces 2.2 ), but as the specification says, converters, validators, and behaviors are still not injection targets. It seems that this will be available from JSF 2.3. Until JSF 2.3, there were a few tricks to obtain validators/converters eligible for injection: Until JSF 2.3 - Custom Validator Eligible For @Inject You probably remember the days when you did this to obtain validators/converters eligible for injection: Until JSF 2.3 - Custom Converter Eligible For @Inject A more complicated task is using @EJB for injecting Enterprise JavaBeans (EJB) session beans. In this case, we need to manually lookup the EJB session bean from Java Naming and Directory Interface (JNDI). When the EJBs are deployed in a Web application ARchive (WAR), the lookup is generally of the following type: When the EJBs are in an Enterprise ARchive (EAR), the common lookup type is as follows: Inject EJB Bean From WAR Inject EJB Bean From EAR Starting with JSF 2.3 this gap has been filled and we can inject (using @Inject) in @FacesConverter (javax.faces.convert.Converter), @FacesValidator (javax.faces.validator.Validator), and @FacesBehavior (javax.faces.component.behavior.Behavior): Specify a new attribute called "managed" on the corresponding annotations; Add into WEB-INF the faces-config.xml with JSF 2.3 XSD (needed for JSF 2.3 milestones); In milestones, you need to manually add the JSF 2.3 XSD, as below: Must Read Injection in more JSF artifacts (by Arjan Tijms) Related JSF 2.3 Converters, validators, and behaviors as injection targets Lifecycle System Event Published After View Rendered As you probably know, JSF 2.2 comes with a significant number of events, but none of them are published right after the view is rendered. In other words, the PreRenderViewEvent event doesn't have a "friend" like PostRenderViewEvent. Well, starting with JSF 2.3 this is not true anymore, because PostRenderViewEvent is available and comes to add consistency to JSF events suite. Subscribe via <f:event> From Page to Listen for PostRenderViewEvent ( example ) Subscribe Programatically to Listen for PostRenderViewEvent From a Custom Component ( example ) And, the output will be: Obviously, PostRenderViewEvent hits processEvent() after encodeEnd(), which means that the rendering process is over. Must Read System event published after view rendered (by Arjan Tijms) Related Just tested JSF 2.3 PostRenderViewEvent under Payara 4.1 Java API Support for the Iterable/Map Interface in UIData and UIRepeat Iterating in UIData (e.g. <h:dataTable>) JSF 2.2 supports the List, native array, and JSF specific DataModel as input for its value binding; you can directly use the Iterable (e.g. Set, Queue); for Map you can use the OmniFaces function, of:mapToList() ; since Iterable is directly supported, you can use it as #{fooBean.fooMap.entrySet()} or #{fooBean.fooMap.keySet()} or#{fooBean.fooMap.values()}; supports the List, native array, and JSF specific DataModel as input for its value binding; you can directly use the Iterable (e.g. Set, Queue); you can use Map directly: Iterating in UIRepeat (e.g. <ui:repeat>) JSF 2.2 supports the List, native array, and JSF specific DataModel as input for its value binding; for Iterable (e.g. Queue, Set) you can use the OmniFaces function, of:iterableToList() ; for Set only (especially useful to Hibernate/JPA users, who are usually using the Set collections for entity relationships) you can use the OmniFaces function, of:setToList() ; if EL 2.2 is present, for Iterable, you can use toArray() (e.g. #{fooBean.fooIterable.toArray()}); for Map you can use the OmniFaces function, of:mapToList() ; if EL 2.2 is present, for Map, you can use toArray() (e.g. #{fooBean.fooMap.entrySet().toArray()} or #{fooBean.fooMap.keySet().toArray()} or #{fooBean.fooMap.values().toArray()}); JSF 2.3 supports the List, native array and JSF specific DataModel as input for its value binding you can use directly the Iterable (e.g. Set, Queue) Must Read Support for the Iterable interface in UIData and UIRepeat (by Arjan Tijms) Support for the Map interface in UIData and UIRepeat (by Arjan Tijms) Related JSF 2.0-2.3 Progress of Iterable/Map support in UIData/UIRepeat (OmniFaces support via utility functions) Support for Custom Types in UIData and UIRepeat JSF 2.3 will provide support for custom types in UIData and UIRepeat. With @FacesDataModel custom DataModel wrappers can be registered. Check the figure below: Usage involve two steps: register your wrapper by annotating it with @FacesDataModel designates the type this wrapper is able to handle via forClass attribute Wrapper Model Use Collection in Your Beans In Data Table - It Works out of the Box With @FacesDataModel custom DataModel wrappers can be registered, but those wrappers cannot (yet) override any of the build-in types. Must Read Support for custom types in UIData and UIRepeat (by Arjan Tijms) JSF 2.3 new feature: registrable DataModels (by Arjan Tijms) Related Registrable DataModels Example Type-Safety Generics for ExternalContext#getInitParameterMap In JSF 2.2 the ExternalContext#getInitParameterMap() returns a raw Map. Starting with JSF 2.3, this method was extended to support generics types. JSF 2.2 - Raw Map JSF 2.3 - Map<String, String> Generics for Converter and Validator Interfaces As you probably know, in JSF 2.2 we can write a custom converter by extending the Converter interface, and a custom validator by extending the Validator interface. The methods defined in these interfaces works with Object class. Starting with JSF 2.3, Converter and Validator have now been parameterized and implementations can concisely define the exact input type. Mojarra 2.3.0-m04 Converter Snippet of Source Code Mojarra 2.3.0-m04 Validator Snippet of Source Code For example, let's suppose that we have the following simple class: We can convert/validate a string against this class by indicating the User type in our converter/validator: JSF 2.3 Custom Converter With Defined Type ( example ) JSF 2.3 Custom Validator With Defined Type ( example ) In JSF 2.3, you can still write custom converters/validators as in JSF 2.2. If you don't want to take advantage of the new generic parameters, you can use the classical approach. Must Read Generics for Converter and Validator interfaces (by Arjan Tijms) Related JSF 2.3 Take advantage of the new generic parameters in Converter<T> and Validator<T> Configuration Facelets default non-hot reload in production JSF has the ability to cache Facelets. In order to update the cache, JSF performs periodic checks of Facelets views changes. In the development stage, you may need to perform this check much more often than in production. For this, you can set the javax.faces.FACELETS_REFRESH_PERIOD context parameter as shown in the following example (the value represents the number of seconds between two consecutive checks). 5 Seconds Timeout There are two special values: -1 means no refresh (cache indefinitely) 0 means no caching at all (always hot reload) Starting with JSF 2.3, when the project stage is Production (default) the Facelets refresh period is -1 (no refresh). Must Read Facelets default to non-hot reload in production (by Arjan Tijms) Conversion/Validation Class-level Bean Validation on CDI-Based Backing Beans JSF 2.2 has several limitations in using Bean Validation. One of them involves the fact the JSF cannot validate the class or method level constraints (so called, cross‚Äêfield validation), only field constrains. JSF 2.3 will come with a new tag named, <f:validateWholeBean/>. As its name suggest, this tag is enables class level validation. This tag contains two important attributes: value - A ValueExpression referencing the bean to be validated. validationGroups - A comma-separated list of validation groups. A validation group is a fully-qualified class name. This feature causes a temporary copy of the bean referenced by the value attribute, for the sole purpose of populating the bean with field values already validated by <f:validateBean/> and then performing class-level validation on the copy. Regardless of the result of the class-level validation, the copy is discarded. JSF 2.3 Class-Level Validation ( example ) Here is a brief example to ensure that the provided name and e-mail fields (contacts) are individually valid and also the e-mail start with that name (e.g. valid: nick, nick_ulm@yahoo.com). ContactValidator Class Implementation Note that a ContactBean instance is passed to the isValid() method. This method will only be called if the individual properties of the ContactBean are valid. This fact allows the isValid() method to inspect the properties and perform effective class-level validation. ValidContact Class Implementation ContactBean Class Implementation This is the backing Bean: ContactGroup Interface Implementation Facelets View The following feature must explicitly be enabled by setting the following application parameter (context parameter) in web.xml: javax.faces.validator.ENABLE_VALIDATE_WHOLE_BEAN. If this parameter is not set, or is set to false, this tag must be a no-op: Must Read Class level bean validation (by Arjan Tijms) Related JSF 2.3 Class-level bean validation on CDI based backing beans JSR 310 Alignment JSF 2.3 will have Java 8 as a minimum dependency. One of the affected artifacts is the <f:convertDateTime/> built-in converter which has been updated in order to support new types for the type attribute, and, depending on the value of the type attribute, the converter will use the java.text.SimpleDateFormat or java.time.format.DateTimeFormatter class for formatting. The upcoming JSF 2.3 now adds new possible values for the type attribute, as follows: localDate, localTime, localDateTime, offsetTime, offsetDateTime, zonedDateTime Simple Bean Using offsetTime Using offsetDateTime Using zonedDateTime When the converter type attribute value is date, time or both, JSF (2.2 and 2.3) uses the java.text.SimpleDateFormat class. Starting with JSF 2.3, when the converter type attribute value is localDate, localTime, localDateTime, offsetTime, offsetDateTime or zonedDateTime, the java.time.format.DateTimeFormatter class will be used. Must Read JDK 8 time support in f:convertDateTime (by Arjan Tijms) Related JSF 2.3 align the <f:convertDateTime/> to the new data and time classes in JDK 8 (JSR 310) Networking Starting with JSF 2.3-m05 we can take advantage of a brand new feature - register a web socket push connection in client side . Thanks to the JSF team (especially to Bauke Scholtz (aka BalusC) ) this feature is available in today milestone via <f:websocket/> tag. R egister a web socket push connection in client side Let's see an example of using the <f:websocket/>. In JSF page, we need to add the <f:websocket/> tag with its two required attributes: channel - This is javax.el.ValueExpression that must be evaluated to String and it represents the name of the web socket channel. A channel name is restricted to alphanumeric characters, hyphens, underscores and periods. A channel can have multiple open web sockets, and each of these sockets will receive the same push notification from the server. onmessage - This is javax.el.ValueExpression that must be evaluated to String and it represents the a JavaScript listener function that is automatically invoked when a push notification is received from the server. The signature of the listener function for onmessage is of type: So, a simple <f:websocket/> tag usage will look like this: By default, when we start the application, the web socket is automatically connected and open. As long as the document is open the web socket is open. When the document is unloaded the web socket is automatically closed. In the web socket is initially successfully connected but the connection is closed as a result of e.g. a network error or server restart, JSF will try to auto-reconnect it at increasing intervals. Now, let's focus on the server side. Here we have to take into account the push messages mechanism. This mechanism is based on javax.faces.push.PushContextinterface and javax.faces.push.Push API. First, you need to know that by default the web socket is application scoped. This means that the managed bean that can push messages to this web socket must be in application scope (annotated with @ApplicationScope). In this case, the push message can be sent by all users and the application itself. Furthermore, you have to inject PushContext via @Push annotation on the given channel name in any CDI/container managed artifact. For example: Finally, we need to write an action method capable to push messages to web socket via PushContext. For example: Let's glue everything together. First, the JSF page: Next, our simple CDI bean: For those implementations that do not support adding an EndPoint dynamically (at the moment only GlassFish/Tyrus), a fake one has to be defined by the application. As BalusC pointed out, this fake endpoint should look like below: Finally, the m05 requires the following settings in web.xml: Done! The complete application was tested under Payara server and it is available here . Must Read WebSocket integration (by Arjan Tijms)